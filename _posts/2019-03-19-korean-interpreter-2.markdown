---
layout: post
title:  "한국어 인터프리터 개발기 #2"
date:   2019-03-19 21:10:00
author: kosmes9779
categories: BomInterpreter
---

## 개요

오랜만의 포스팅이다.

언어와 개발환경을 만들기 위해 여러가지를 고민했다. 단순히 네이티브로 할까 가상환경을 만들것인가와 ...

암튼 고민했다. 아몰랑


## 인터프리터 vs 바이트코드

사실 처음부터 네이티브는 고민 대상에 올라가있지도 않았다. 기계어 변환도 문제거니와 ... 끆 기술 부족이다. 그리고 언어를 처음 배울때 비 관리 언어로 시작하는 것은 상당히 난이도가 있다고 느끼기 때문에 관리 언어로 구현하기 마음먹었다.


## 원 모어 띵

그 뒤로 여러가지를 공부했다. 먼저 네이티브 실행 파일의 구성요소, 자바 바이트코드와 class 구성 및 vm, msil 바이트코드 마지막으로 lua를 뜯어보았다. 이 소스중에서 중점적으로 확인 한 것들이 몇가지가 있는다.

 * 바이트코드 구성
 * 메모리 관리

### 네이티브 코드

일단 그냥 궁금해서 네이티브 코드를 뜯어봤다. 작게는 각 명령어가 어떻게 작동하는지와 PE파일의 구성, 각 섹션들. 먼저 네이티브 코드를 뜯어버리니 다른 바이트언어들과 작동하는 방식이 크게 다른 점이 없다는 것을 알게 되었다.

바이트코드 구성은 어셈블리어니까 패스

#### 파일 구성

일단 파일 구성. 도스 부분은 그렇게 크게 관심이 없었고 섹션부분을 주요하게 살펴보았다. 

먼저 섹션의 중요한 부분들을 담고있는 헤더다.

```C
typedef struct _IMAGE_FILE_HEADER {
    ... 타겟 CPU 정보, 섹션 개수 등등 ...
} IMAGE_NT_HEADER, *PIMAGE_NT_HEADER;
```

이건 그냥 파일 메인 해더부분이고

```C
typedef struct _IMAGE_DATA_DIRECTORY {
    ... 실제 코드 정보, 위치, 크기 ...
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16

typedef struct _IMAGE_OPTIONAL_HEADER {
    ... 섹션의 정보, 위치, 이미지 크기, 헤더 크기, _IMAGE_DATA_DIRECTORY 리스트 ...
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;
```

이게 섹션의 정보를 담고있는 해더인데 안의 내용까지 다 쓰면 너무 길어져서 뺐다. 중요한건 그게 아니니까.

주요한 섹션은 초기화된 데이터인 data함수랑 실행 가능한 코드를 포함한 text 섹션, 그리고 알수 없는 rsrc 리소스 섹션등이 있다.

암튼 이러한 정보를 가지고 있었다.


### JVM

다음은 아마 가장 대중적인 가상 머신인 JVM이다. 작년 기준 깃허브에서 자바가 c#보다 많은 배포수를 가지고 있다. 아마라고 한 이유는 여러 조사 방법에 따라 달라질 수 있기 때문이다...

암튼 JVM은 거대한 생태계를 구축한 만큼 여러 하자가 있더라 하더라도 무시할 수 없음이 틀림 없다. 


#### 바이트코드

JVM은 각 타입별로 다른 OP CODE를 가지고 있다 먼뜻이냐면 값을 로드하는 CONST라는 OP CODE 가 있으면 이게 정수형, 실수, 논리 등등 다 따로 가지고 있다는 거다.

|접두사/접미사|피연산자 타입|
|-|-|
|i|integer|
|l|long|
|s|short|
|b|byte|
|c|character|
|f|float|
|d|double|
|a|ref|

|타입|opcode(문자열)|opcode(16진수)|
|-|-|-|
|i|iconst|0x15|
|l|lload|0x16|
등등등 자세한 내용은 [여기](https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings)에서...


#### 파일 구성

파일 구성이라고 했지만 사실 class의 구성이다. class를 만든다음 jvm의 class loader에 의해 로드 된 뒤 메모리에 올라가니까... JAR은 그냥 class 압축한거니까... 그리고 인터프리터 환경을 만들 것이므로 목적파일을 만들 필요가 없다는 점도 작용했다.

인터넷에 자바 class 파일 구조를 검색하니 나만큼이나 큰 이미지 파일이 반겨주었다.

![크고 아름답다](https://i.imgur.com/oDfhZFZ.png)

이 이미지에 따르면 첫번째 MAGIC이랑 버전등이 들어가있고 그 뒤로는 constant 정보를 가지고 있는 섹션이 있고, 그 뒤로는 클래스의 구성 요소들을 담고 있는 섹션이 뒤를 이은다. 그리고는 그 클래스의 함수 정보를 가지고 있는 섹션이 있고 그 안에 바이트코드가 들어있다.

정리하자면 
 * 이름, 부모 클래스, 인터페이스
 * 데이터: 숫자, 문자열 그리고 타입 데이터,
 * 클래스 참조
 * 클래스 설명 ()
 * 특성
 * 필드
    * 이름, 형
    * 설명
    * 특성
 * 메소드
    * 이름, 반환 형, 인자 형
    * 설명
    * 특성
    * 코드
 

그러하다

### MSIL

IT의 공룡 기업... 순위권에 들어가는 마이크로소프트에서 개발한 중간 언어. 순위권에 들어가는 이유로는 PC시장에서는 갑이지만 메인프레임에서는 IBM에 밀리고 모바일에서는 애플 구글에 밀리고... 커흑... 마이 깟.

암튼 이상한 소리를 했지만 탑 기업인 만큼 깔끔하게 만들었을 거라고 기대후 알아보았다.

#### 바이트코드

음 기대만큼 깔끔했다. 자바에서는 형 종류마다 OP CODE를 다 붙였다면 msil에서는 OP CODE를 넣으면 타입은 알아서 계산된다.

```
stloc.0
stloc.1
add
```

글을 쓰면서 생각해본건데 VM 내에서 형변환을 알아서 하는거같다.

그리고 인자에 넣은 값이랑 로컬 변수의 메모리가 분리되어서 다른 명령어로 스택에 입력할 수 있다

자세한 내용은 [여기](https://docs.microsoft.com/ko-kr/dotnet/api/system.reflection.emit.opcodes.stloc?view=netframework-4.7.2)를 참조!


#### 파일 구성

~~정보가 없어!~~


그러하다

## 결론

어렵다. 아직까지도 완벽하게 분석하지 못했지만 그래도 생각보다 많은 것들을 알게되었다.

자바는 그냥 클래스를 파일로 만들어서 박아둔거같고. ms cil은 여윽시 마소제품답게 깔끔한거같다.

## 추가

그리고 프로그램 언어를 bom으로 바꿨다. 코스모스는 이상하고 두번째로 바꿨던 binary는 순 한국어인 비나리 뜻은 축복의 말인데... 영어로 쓰면.... 바이너리...